--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,7 @@
 VERSION = 1
 PATCHLEVEL = 1
 SUBLEVEL = 5
-EXTRAVERSION =
+EXTRAVERSION = -IFX-LXDB
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 VERSION_FILE = $(obj)include/version_autogenerated.h
 
@@ -44,6 +44,25 @@
 # Deal with colliding definitions from tcsh etc.
 VENDOR=
 
+# Default algorithm form compressing u-boot.bin
+ifndef COMPRESS
+COMPRESS=none
+COMPRESS_FILE=$(obj)u-boot.img
+else
+ifeq ($(COMPRESS),lzma)
+COMPRESS_FILE=$(obj)u-boot.limg
+endif
+ifeq ($(COMPRESS),bz2)
+COMPRESS_FILE=$(obj)u-boot.bzimg
+endif
+ifeq ($(COMPRESS),gzip)
+COMPRESS_FILE=$(obj)u-boot.zimg
+endif
+ifeq ($(COMPRESS),none)
+COMPRESS_FILE=$(obj)u-boot.img
+endif
+endif
+
 #########################################################################
 #
 # U-boot build supports producing a object files to the separate external
@@ -155,6 +174,11 @@
 endif
 endif
 
+
+
+
+
+
 export	CROSS_COMPILE
 
 # load other configuration
@@ -163,7 +187,9 @@
 #########################################################################
 # U-Boot objects....order is important (i.e. start must be first)
 
-OBJS  = cpu/$(CPU)/start.o
+OBJS  = cpu/$(CPU)/$(BOARDDIR)/start.o
+OBJS_BOOTSTRAP  = cpu/$(CPU)/$(BOARDDIR)/start_bootstrap.o
+
 ifeq ($(CPU),i386)
 OBJS += cpu/$(CPU)/start16.o
 OBJS += cpu/$(CPU)/reset.o
@@ -186,11 +212,11 @@
 
 LIBS  = lib_generic/libgeneric.a
 LIBS += board/$(BOARDDIR)/lib$(BOARD).a
-LIBS += cpu/$(CPU)/lib$(CPU).a
+LIBS += cpu/$(CPU)/$(BOARDDIR)/lib$(CPU).a
 ifdef SOC
 LIBS += cpu/$(CPU)/$(SOC)/lib$(SOC).a
 endif
-LIBS += lib_$(ARCH)/lib$(ARCH).a
+LIBS += lib_$(ARCH)/$(BOARDIR)/lib$(ARCH).a
 LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \
 	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a
 LIBS += net/libnet.a
@@ -198,27 +224,54 @@
 LIBS += rtc/librtc.a
 LIBS += dtt/libdtt.a
 LIBS += drivers/libdrivers.a
-LIBS += drivers/nand/libnand.a
-LIBS += drivers/nand_legacy/libnand_legacy.a
+#LIBS += drivers/nand_$(BOARDDIR)/libnand.a
+#LIBS += drivers/nand_legacy/libnand_legacy.a
 LIBS += drivers/sk98lin/libsk98lin.a
 LIBS += post/libpost.a post/cpu/libcpu.a
 LIBS += common/libcommon.a
 LIBS += $(BOARDLIBS)
 
 LIBS := $(addprefix $(obj),$(LIBS))
+
+
+LIBS_BOOTSTRAP  = lib_bootstrap/libbootstrap.a 
+LIBS_BOOTSTRAP+= board/$(BOARDDIR)/lib$(BOARD).a 
+#LIBS_BOOTSTRAP+= board/ifx/libifx.a 
+LIBS_BOOTSTRAP+= cpu/$(CPU)/$(BOARDDIR)/lib$(CPU).a
+
+#HEAD_OBJS = cpu/$(CPU)/$(BOARDDIR)/start.o lib_$(ARCH)/board.o
+
+#HEAD_LIBS  = board/$(BOARDDIR)/lib$(BOARD).a
+#HEAD_LIBS += cpu/$(CPU)/$(BOARDDIR)/lib$(CPU).a
+#HEAD_LIBS += lib_$(ARCH)/lib$(ARCH).a
+#HEAD_LIBS += lib_generic/libgeneric.a
+#HEAD_LIBS += common/console.o
+#HEAD_LIBS += common/devices.o
+#HEAD_LIBS += common/cmd_bootm.o
+
+#.PHONY : $(LIBS) $(HEAD_LIBS)
 .PHONY : $(LIBS)
+.PHONY : $(LIBS_BOOTSTRAP)
 
 # Add GCC lib
 PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
 
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
+	  #examples 
 SUBDIRS	= tools \
-	  examples \
 	  post \
 	  post/cpu
 .PHONY : $(SUBDIRS)
 
+# HEAD_SUBDIRS = tools
+#HEAD_SUBDIRS = lib_generic \
+#	  cpu/$(CPU) \
+#	  board/$(BOARDDIR) \
+#	  common \
+#	  lib_$(ARCH)
+#.PHONY : $(HEAD_SUBDIRS)
+
 ifeq ($(CONFIG_NAND_U_BOOT),y)
 NAND_SPL = nand_spl
 U_BOOT_NAND = $(obj)u-boot-nand.bin
@@ -227,13 +280,76 @@
 __OBJS := $(subst $(obj),,$(OBJS))
 __LIBS := $(subst $(obj),,$(LIBS))
 
+#__HEAD_OBJS := $(subst $(obj),,$(HEAD_OBJS))
+#__HEAD_LIBS := $(subst $(obj),,$(HEAD_LIBS))
+
 #########################################################################
 #########################################################################
 
 ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)
+#IFX_ALL = $(obj)u-boot.ifx $(obj)head.srec $(obj)head.bin $(obj)head $(obj)head.map $(COMPRESS_FILE) $(obj)u-boot.srec
+IFX_ALL = $(obj)u-boot.srec $(obj)u-boot.ifx $(obj)u-boot.lzimg $(obj)System.map $(obj)bootstrap.bin
 
 all:		$(ALL)
 
+ifx_all:	$(IFX_ALL)
+
+
+$(obj)u-boot.ifx: $(obj)System.map $(obj)bootstrap.bin $(obj)u-boot.lzimg	
+		@cat $(obj)bootstrap.bin > $(obj)u-boot.ifx
+		@cat $(obj)u-boot.lzimg >> $(obj)u-boot.ifx
+
+$(obj)u-boot.lzimg: $(obj)u-boot.bin System.map
+#		@lzma -f -z --best -v $(obj)u-boot.bin
+		@lzma e $(obj)u-boot.bin $(obj)u-boot.bin.lzma
+		@./tools/mkimage -A mips -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-n 'u-boot image' -d $(obj)u-boot.bin.lzma $@
+
+$(obj)ld_uboot.img: $(obj)u-boot.ifx $(obj)u-boot.lzimg $(obj)System.map $(obj)bootstrap.bin	
+		@  cp -f $(obj)u-boot.ifx $(obj)u-boot.bin
+		@ ./mkbootimg.incaip2 $(obj)ld_uboot.img < ld_uboot.conf
+
+
+
+
+$(obj)u-boot.zimg:	$(obj)u-boot.bin $(obj)System.map
+		gzip $(obj)u-boot.bin
+		./tools/mkimage -A $(ARCH) -T firmware -C gzip \
+                -a 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			 sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.gz $@
+
+$(obj)u-boot.bzimg:	$(obj)u-boot.bin $(obj)System.map
+		bzip $(obj)u-boot.bin
+		./tools/mkimage -A $(ARCH) -T firmware -C bzip2 \
+		-a 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.bz2 $@
+
+$(obj)u-boot.limg:	$(obj)u-boot.bin $(obj)System.map
+#		@lzma -f -z --best -v $(obj)u-boot.bin
+		@lzma e $(obj)u-boot.bin $(obj)u-boot.bin.lzma
+		./tools/mkimage -A $(ARCH) -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.bin.lzma $@
+
+$(obj)u-boot.img:	$(obj)u-boot.bin $(obj)System.map
+		./tools/mkimage -A $(ARCH) -T firmware -C none \
+		-a 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.bin $@
+
 $(obj)u-boot.hex:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O ihex $< $@
 
@@ -243,28 +359,36 @@
 $(obj)u-boot.bin:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
 
-$(obj)u-boot.img:	$(obj)u-boot.bin
-		./tools/mkimage -A $(ARCH) -T firmware -C none \
-		-a $(TEXT_BASE) -e 0 \
-		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
-			sed -e 's/"[	 ]*$$/ for $(BOARD) board"/') \
-		-d $< $@
-
 $(obj)u-boot.dis:	$(obj)u-boot
 		$(OBJDUMP) -d $< > $@
 
-$(obj)u-boot:		depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
+$(obj)u-boot:	depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
 		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
 		cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
 			--start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \
 			-Map u-boot.map -o u-boot
 
+
+
+$(obj)bootstrap.bin:	$(obj)bootstrap
+		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(obj)bootstrap :		depend version $(SUBDIRS) $(OBJS_BOOTSTRAP) $(LIBS_BOOTSTRAP) $(LDSCRIPT_BOOTSTRAP)
+		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS_BOOTSTRAP) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
+		$(LD) $(LDFLAGS_BOOTSTRAP) $$UNDEF_SYM $(OBJS_BOOTSTRAP) \
+			--start-group $(LIBS_BOOTSTRAP) --end-group $(PLATFORM_LIBS) \
+			-Map bootstrap.map -o bootstrap
+
 $(OBJS):
-		$(MAKE) -C cpu/$(CPU) $(if $(REMOTE_BUILD),$@,$(notdir $@))
+		$(MAKE) -C cpu/$(CPU)/$(BOARDDIR) $(if $(REMOTE_BUILD),$@,$(notdir $@))
 
 $(LIBS):
 		$(MAKE) -C $(dir $(subst $(obj),,$@))
 
+
+$(LIBS_BOOTSTRAP):
+		$(MAKE) -C `dirname $@`
+
 $(SUBDIRS):
 		$(MAKE) -C $@ all
 
@@ -295,14 +419,14 @@
 
 tags ctags:
 		ctags -w -o $(OBJTREE)/ctags `find $(SUBDIRS) include \
-				lib_generic board/$(BOARDDIR) cpu/$(CPU) lib_$(ARCH) \
+				lib_generic board/$(BOARDDIR) cpu/$(CPU)/$(BOARDDIR) lib_$(ARCH) \
 				fs/cramfs fs/fat fs/fdos fs/jffs2 \
 				net disk rtc dtt drivers drivers/sk98lin common \
 			\( -name CVS -prune \) -o \( -name '*.[ch]' -print \)`
 
 etags:
 		etags -a -o $(OBJTREE)/etags `find $(SUBDIRS) include \
-				lib_generic board/$(BOARDDIR) cpu/$(CPU) lib_$(ARCH) \
+				lib_generic board/$(BOARDDIR) cpu/$(CPU)/$(BOARDDIR) lib_$(ARCH) \
 				fs/cramfs fs/fat fs/fdos fs/jffs2 \
 				net disk rtc dtt drivers drivers/sk98lin common \
 			\( -name CVS -prune \) -o \( -name '*.[ch]' -print \)`
@@ -2032,7 +2156,20 @@
 # MIPS
 #========================================================================
 #########################################################################
-## MIPS32 4Kc
+## Infineon MIPS generic u-boot config 
+#########################################################################
+danube_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) mips mips danube
+
+amazon_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) mips mips amazon
+
+
+incaip2_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) mips mips incaip2
+
+#########################################################################
+## MIPS32 4kc
 #########################################################################
 
 xtract_incaip = $(subst _100MHz,,$(subst _133MHz,,$(subst _150MHz,,$(subst _config,,$1))))
@@ -2246,6 +2383,8 @@
 	rm -f $(obj)include/bmp_logo.h
 	find nand_spl -lname "*" -print | xargs rm -f
 	rm -f nand_spl/u-boot-spl nand_spl/u-boot-spl.map
+	rm -f lib_bootstrap/*.o
+	rm -f lib_bootstrap/*.a
 
 clobber:	clean
 	find $(OBJTREE) -type f \( -name .depend \
@@ -2254,7 +2393,7 @@
 		| xargs -0 rm -f
 	rm -f $(OBJS) $(obj)*.bak $(obj)ctags $(obj)etags $(obj)TAGS $(obj)include/version_autogenerated.h
 	rm -fr $(obj)*.*~
-	rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL)
+	rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL) $(IFX_ALL)
 	rm -f $(obj)tools/crc32.c $(obj)tools/environment.c $(obj)tools/env/crc32.c
 	rm -f $(obj)tools/inca-swap-bytes $(obj)cpu/mpc824x/bedbug_603e.c
 	rm -f $(obj)include/asm/proc $(obj)include/asm/arch $(obj)include/asm
--- /dev/null
+++ b/build_danube.sh
@@ -0,0 +1,28 @@
+#!/bin/sh
+IFX_CONFIG_FLASH_SIZE=8
+IFX_CONFIG_MEMORY_SIZE=30
+CONFIG_RAM_TEXT_BASE=0xA0400000
+
+#prepare_headers()
+#{
+#	cp -f include/flash_$1.h \
+#	include/flash.h
+#	cp -f include/net_$1.h \
+#	include/net.h
+#	cp -f include/asm-mips/cacheops_$1.h \
+#	include/asm-mips/cacheops.h
+#	cp -f include/asm-mips/mipsregs_$1.h \
+#	include/asm-mips/mipsregs.h
+#}
+#prepare_headers "danube"
+UBOOT_COMPRESS=lzma
+UBOOT_CFLAGS="-DCONFIG_IFX_MIPS -DCONFIG_LZMA -DIFX_CONFIG_MEMORY_SIZE=${IFX_CONFIG_MEMORY_SIZE} -DIFX_CONFIG_FLASH_SIZE=${IFX_CONFIG_FLASH_SIZE}"
+
+rm -f .config_ok
+
+make CROSS_COMPILE="mips-linux-uclibc-" CROSS_COMPILE_UCLIBC=1 COMPRESS=${UBOOT_COMPRESS} PLATFORM_CPU=mips32r2 IFX_CFLAGS="${UBOOT_CFLAGS}" UBOOT_RAM_TEXT_BASE=${CONFIG_RAM_TEXT_BASE} CPU_TYPE=${IFX_CONFIG_CPU} danube_config distclean
+
+CROSS_COMPILE="mips-linux-uclibc-" CROSS_COMPILE_UCLIBC=1 COMPRESS=${UBOOT_COMPRESS} PLATFORM_CPU=mips32r2 IFX_CFLAGS="${UBOOT_CFLAGS}" make UBOOT_RAM_TEXT_BASE=${CONFIG_RAM_TEXT_BASE} CPU_TYPE=${IFX_CONFIG_CPU} danube_config
+       echo -n > .config_ok
+
+CROSS_COMPILE="mips-linux-uclibc-" CROSS_COMPILE_UCLIBC=1 COMPRESS=${UBOOT_COMPRESS} PLATFORM_CPU=mips32r2 IFX_CFLAGS="${UBOOT_CFLAGS}" make UBOOT_RAM_TEXT_BASE=${CONFIG_RAM_TEXT_BASE} BOOTSTRAP_PRINTF_STATUS=$2 CPU_TYPE=${IFX_CONFIG_CPU} ifx_all
--- a/common/Makefile
+++ b/common/Makefile
@@ -46,7 +46,7 @@
 	  env_nand.o env_dataflash.o env_flash.o env_eeprom.o \
 	  env_nvram.o env_nowhere.o \
 	  exports.o \
-	  flash.o fpga.o ft_build.o \
+	  flash_$(BOARD).o fpga.o ft_build.o \
 	  hush.o kgdb.o lcd.o lists.o lynxkdi.o \
 	  memsize.o miiphybb.o miiphyutil.o \
 	  s_record.o serial.o soft_i2c.o soft_spi.o spartan2.o spartan3.o \
@@ -60,7 +60,7 @@
 
 all:	$(LIB) $(AOBJS)
 
-$(LIB): $(obj).depend $(OBJS)
+$(LIB): $(OBJS)
 	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 $(obj)environment.o: $(src)environment.c $(obj)../tools/envcrc
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -31,6 +31,7 @@
 #include <malloc.h>
 #include <zlib.h>
 #include <bzlib.h>
+#include <LzmaWrapper.h>
 #include <environment.h>
 #include <asm/byteorder.h>
 
@@ -79,6 +80,8 @@
 # define CHUNKSZ (64 * 1024)
 #endif
 
+#ifndef CFG_HEAD_CODE
+
 int  gunzip (void *, int, unsigned char *, unsigned long *);
 
 static void *zalloc(void *, unsigned, unsigned);
@@ -341,6 +344,7 @@
 #endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
 		}
 		break;
+#ifndef CONFIG_REMOVE_GZIP
 	case IH_COMP_GZIP:
 		printf ("   Uncompressing %s ... ", name);
 		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
@@ -350,6 +354,7 @@
 			do_reset (cmdtp, flag, argc, argv);
 		}
 		break;
+#endif /* CONFIG_REMOVE_GZIP */
 #ifdef CONFIG_BZIP2
 	case IH_COMP_BZIP2:
 		printf ("   Uncompressing %s ... ", name);
@@ -369,6 +374,18 @@
 		}
 		break;
 #endif /* CONFIG_BZIP2 */
+#ifdef CONFIG_LZMA
+	case IH_COMP_LZMA:
+		printf ("   Uncompressing %s ... ", name);
+		i = lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &unc_len);
+		if (i != LZMA_RESULT_OK) {
+			printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+			SHOW_BOOT_PROGRESS (-6);
+			udelay(100000);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+		break;
+#endif /* CONFIG_LZMA */
 	default:
 		if (iflag)
 			enable_interrupts();
@@ -1176,6 +1193,8 @@
 );
 #endif	/* CFG_CMD_IMLS */
 
+#endif	/* ! CFG_HEAD_CODE */
+
 void
 print_image_hdr (image_header_t *hdr)
 {
@@ -1270,12 +1289,15 @@
 	case IH_COMP_NONE:	comp = "uncompressed";		break;
 	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
 	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
+	case IH_COMP_LZMA:      comp = "lzma compressed";       break;	
 	default:		comp = "unknown compression";	break;
 	}
 
 	printf ("%s %s %s (%s)", arch, os, type, comp);
 }
 
+#ifndef CFG_HEAD_CODE
+
 #define	ZALLOC_ALIGNMENT	16
 
 static void *zalloc(void *x, unsigned items, unsigned size)
@@ -1427,3 +1449,5 @@
 }
 
 #endif /* CONFIG_LYNXKDI */
+
+#endif /* ! CFG_HEAD_CODE */
--- a/common/cmd_flash.c
+++ b/common/cmd_flash.c
@@ -196,9 +196,17 @@
 }
 
 static int
-flash_fill_sect_ranges (ulong addr_first, ulong addr_last,
-			int *s_first, int *s_last,
-			int *s_count )
+flash_fill_sect_ranges(
+	ulong *addr_first_sect_start,
+	ulong addr_first,
+	ulong *addr_last_sect_end,
+	ulong addr_last,
+	int *s_first,
+	int *s_last,
+	int *bPartialStart,
+	int *bPartialEnd,
+	int *s_count,
+	unsigned int bPartialErase)
 {
 	flash_info_t *info;
 	ulong bank;
@@ -211,9 +219,7 @@
 		s_last [bank] = -1;	/* last  sector to erase	*/
 	}
 
-	for (bank=0,info=&flash_info[0];
-	     (bank < CFG_MAX_FLASH_BANKS) && (addr_first <= addr_last);
-	     ++bank, ++info) {
+	for (bank=0, info=&flash_info[0]; (bank < CFG_MAX_FLASH_BANKS) && (addr_first <= addr_last); ++bank, ++info) {
 		ulong b_end;
 		int sect;
 		short s_end;
@@ -225,7 +231,6 @@
 		b_end = info->start[0] + info->size - 1;	/* bank end addr */
 		s_end = info->sector_count - 1;			/* last sector   */
 
-
 		for (sect=0; sect < info->sector_count; ++sect) {
 			ulong end;	/* last address in current sect	*/
 
@@ -238,11 +243,21 @@
 
 			if (addr_first == info->start[sect]) {
 				s_first[bank] = sect;
+			} else if (addr_first > info->start[sect] && addr_first <= end && bPartialErase) {
+				*addr_first_sect_start = info->start[sect];
+				s_first[bank] = sect;
+				*bPartialStart = 1;
 			}
+
 			if (addr_last  == end) {
 				s_last[bank]  = sect;
+			} else if (addr_last >= info->start[sect] && addr_last < end && bPartialErase) {
+				*addr_last_sect_end = end;
+				s_last[bank] = sect;
+				*bPartialEnd = 1;
 			}
 		}
+		
 		if (s_first[bank] >= 0) {
 			if (s_last[bank] < 0) {
 				if (addr_last > b_end) {
@@ -316,6 +331,8 @@
 	struct part_info *part;
 	u8 dev_type, dev_num, pnum;
 #endif
+	unsigned int bPartialErase = 0;
+
 	int rcode = 0;
 
 	if (argc < 2) {
@@ -368,8 +385,8 @@
 		}
 	}
 #endif
-
-	if (argc != 3) {
+	
+	if (argc != 4) {
 		printf ("Usage:\n%s\n", cmdtp->usage);
 		return 1;
 	}
@@ -397,11 +414,117 @@
 		return 1;
 	}
 
-	rcode = flash_sect_erase(addr_first, addr_last);
+	printf ("Erase Flash from 0x%08lx to 0x%08lx\n", addr_first, addr_last);
+	if(argc == 4) {
+		bPartialErase = simple_strtoul(argv[3], NULL, 10);
+	}
+
+	rcode = flash_sect_erase(addr_first, addr_last, bPartialErase);
 	return rcode;
 }
 
-int flash_sect_erase (ulong addr_first, ulong addr_last)
+int flerase_Partial(
+	ulong addr_first_sect_start,
+	ulong addr_first,
+	ulong addr_last_sect_end,
+	ulong addr_last,
+	flash_info_t *info,
+	int first_sect,
+	int last_sect,
+	int bFirstPartial,
+	int bLastPartial) {
+	unsigned int firstMemLen = 0;
+	unsigned int lastMemLen = 0;
+	unsigned int sectMemLen = 0;
+	uchar *pSavedFirstMem = NULL;
+	uchar *pSavedLastMem = NULL;
+	uchar *pSavedSectMem = NULL;
+	int bSectPartial = 0;
+	int rt_code = 0;
+
+	debug("%s ... 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%p, %d, %d, %d, %d\n", __FUNCTION__, addr_first_sect_start, addr_first, addr_last_sect_end, addr_last, info, first_sect, last_sect, bFirstPartial, bLastPartial);
+
+	if (bFirstPartial && bLastPartial && (first_sect == last_sect))
+	{
+		ulong b_end = info->start[0] + info->size - 1;
+		ulong end = (first_sect == (info->sector_count - 1)) ? b_end : info->start[first_sect + 1] - 1;
+		sectMemLen = end - info->start[first_sect] + 1;
+		pSavedSectMem = (uchar *)calloc(sectMemLen, sizeof(char));
+		if (pSavedSectMem == NULL)
+		{
+			debug("calloc %u FAILED\n", sectMemLen);
+			rt_code = 1;
+			goto ret;
+		}
+		memset(pSavedSectMem, 0xff, sectMemLen);
+		bSectPartial = 1;
+		memcpy(pSavedSectMem, (uchar *)addr_first_sect_start, addr_first - addr_first_sect_start);
+		memcpy(pSavedSectMem + (addr_last - info->start[first_sect]) + 1, addr_last + 1, end - addr_last);
+	}
+	else
+	{
+		if (bFirstPartial){
+			firstMemLen = addr_first - addr_first_sect_start + 1;
+			pSavedFirstMem = (uchar *)calloc(firstMemLen,sizeof(char));
+			memcpy(pSavedFirstMem,(uchar *)addr_first_sect_start,firstMemLen - 1);
+		}
+		if (bLastPartial){
+			lastMemLen = addr_last_sect_end - addr_last + 1;
+			pSavedLastMem = (uchar *)calloc(lastMemLen,sizeof(char));
+			memcpy(pSavedLastMem,(uchar *)addr_last + 1,lastMemLen - 1);
+		}
+	}
+
+	if (bFirstPartial){
+		if(flash_erase (info, first_sect, first_sect)) {
+			printf("%s ... Couldn't erase sector %d\n", __FUNCTION__, first_sect);
+			rt_code = 1;
+			goto ret;
+		}
+		debug("%s ... erase sector %d done!\n", __FUNCTION__, first_sect);
+	}
+	
+	if (bLastPartial && first_sect != last_sect){
+		if(flash_erase (info, last_sect, last_sect)) {
+			printf("%s ... Couldn't erase sector %d\n", __FUNCTION__, last_sect);
+			rt_code = 1;
+			goto ret;
+		}
+		debug("%s ... erase sector %d done!\n", __FUNCTION__, last_sect);
+	}
+
+	if (bFirstPartial && bLastPartial && (first_sect == last_sect))
+	{
+		flash_write(pSavedSectMem, (uchar *)addr_first_sect_start, sectMemLen);
+		debug("flash_write from 0x%08x with len %u\n", addr_first_sect_start, sectMemLen);
+	}
+	else
+	{
+		if (bFirstPartial){
+			if(flash_write(pSavedFirstMem,(uchar *)addr_first_sect_start,firstMemLen - 1)) {
+				printf("%s ... Couldn't write at 0x%08lx length %d\n", __FUNCTION__, addr_first_sect_start,firstMemLen - 1);
+				rt_code = 1;
+				goto ret;
+			}
+		}
+		if (bLastPartial){
+			if(flash_write(pSavedLastMem,(uchar *)addr_last + 1,lastMemLen - 1)) {
+				printf("%s ... Couldn't write at 0x%08lx length %d\n", __FUNCTION__, addr_last, lastMemLen - 1);
+				rt_code = 1;
+			}
+		}
+	}
+ret:
+	if (bFirstPartial)
+		free(pSavedFirstMem);
+	if (bLastPartial)
+		free(pSavedLastMem);
+	if (bSectPartial)
+		free(pSavedSectMem);
+	return rt_code;
+}
+
+int flash_sect_erase (ulong addr_first, ulong addr_last, unsigned int bPartialErase)
 {
 	flash_info_t *info;
 	ulong bank;
@@ -413,27 +536,66 @@
 	int erased = 0;
 	int planned;
 	int rcode = 0;
-
-	rcode = flash_fill_sect_ranges (addr_first, addr_last,
-					s_first, s_last, &planned );
+	int bPartialStart = 0;		// Start sector has to be erased partially
+	int bPartialEnd = 0;		// End sector has to be erased partially
+	ulong addr_first_sect_start = 0;// Sector start address of location addr_start
+	ulong addr_last_sect_end = 0;	// Sector end address of location addr_last
+
+	rcode = flash_fill_sect_ranges (
+			&addr_first_sect_start,
+			addr_first,
+			&addr_last_sect_end,
+			addr_last,
+			s_first,
+			s_last,
+			&bPartialStart,
+			&bPartialEnd,
+			&planned,
+			bPartialErase );
 
 	if (planned && (rcode == 0)) {
-		for (bank=0,info=&flash_info[0];
-		     (bank < CFG_MAX_FLASH_BANKS) && (rcode == 0);
-		     ++bank, ++info) {
+		for (bank=0, info=&flash_info[0]; (bank < CFG_MAX_FLASH_BANKS) && (rcode == 0); ++bank, ++info) {
+			ulong b_end = info->start[0] + info->size - 1;	/* bank end addr */
 			if (s_first[bank]>=0) {
-				erased += s_last[bank] - s_first[bank] + 1;
-				debug ("Erase Flash from 0x%08lx to 0x%08lx "
-					"in Bank # %ld ",
-					info->start[s_first[bank]],
-					(s_last[bank] == info->sector_count) ?
-						info->start[0] + info->size - 1:
-						info->start[s_last[bank]+1] - 1,
-					bank+1);
-				rcode = flash_erase (info, s_first[bank], s_last[bank]);
+				if(bPartialErase) {
+					rcode = flerase_Partial(
+							addr_first_sect_start,
+							addr_first,
+							addr_last_sect_end,
+							addr_last,
+							info,
+							s_first[bank],
+							s_last[bank],
+							bPartialStart,
+							bPartialEnd);
+				}			
+
+				//Erase full sectores
+				if (bPartialStart)
+					s_first[bank] += 1;
+				if (bPartialEnd)
+					s_last[bank] -= 1;
+				if (s_last[bank] >= s_first[bank]) {
+					erased += s_last[bank] - s_first[bank] + 1;
+					debug ("Erase Flash from 0x%08lx to 0x%08lx in Bank # %ld ",
+						info->start[s_first[bank]],
+						(s_last[bank] == info->sector_count) ?
+							info->start[0] + info->size - 1:
+							info->start[s_last[bank]+1] - 1,
+						bank + 1);
+					rcode = flash_erase (info, s_first[bank], s_last[bank]);
+				}
 			}
 		}
-		printf ("Erased %d sectors\n", erased);
+		
+		if (erased && !bPartialErase) {
+			printf ("Erased %d sectors\n", erased);
+		} else if (bPartialErase){
+			printf ("Partial erased from 0x%08lx to 0x%08lx\n", addr_first, addr_last);
+		} else {
+			printf ("Error: start and/or end address not on sector boundary\n");
+			rcode = 1;
+		}
 	} else if (rcode == 0) {
 		puts ("Error: start and/or end address"
 			" not on sector boundary\n");
@@ -629,8 +791,22 @@
 	int protected, i;
 	int planned;
 	int rcode;
-
-	rcode = flash_fill_sect_ranges( addr_first, addr_last, s_first, s_last, &planned );
+	int bPartialStart = 0;		// Start sector has to be erased partially
+	int bPartialEnd = 0;		// End sector has to be erased partially
+	ulong addr_first_sect_start = 0;// Sector start address of location addr_start
+	ulong addr_last_sect_end = 0;	// Sector end address of location addr_last
+
+	rcode = flash_fill_sect_ranges (
+			&addr_first_sect_start,
+			addr_first,
+			&addr_last_sect_end,
+			addr_last,
+			s_first,
+			s_last,
+			&bPartialStart,
+			&bPartialEnd,
+			&planned,
+			1 );
 
 	protected = 0;
 
@@ -690,7 +866,7 @@
 );
 
 U_BOOT_CMD(
-	erase,   3,   1,  do_flerase,
+	erase,   4,   1,  do_flerase,
 	"erase   - erase FLASH memory\n",
 	"start end\n"
 	"    - erase FLASH from addr 'start' to addr 'end'\n"
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -540,8 +540,19 @@
 	extern char * env_name_spec;
 
 	printf ("Saving Environment to %s...\n", env_name_spec);
-
+#if 1
+	if(saveenv() == 0) {
+#ifdef UBOOT_ENV_COPY
+		saveenv_copy();
+#else
+		;
+#endif //UBOOT_ENV_COPY
+	} else
+		return 1;
+	return 0;
+#else
 	return (saveenv() ? 1 : 0);
+#endif
 }
 
 
--- a/common/console.c
+++ b/common/console.c
@@ -324,7 +324,7 @@
 #endif
 
 /** U-Boot INIT FUNCTIONS *************************************************/
-
+#ifndef CFG_HEAD_CODE
 int console_assign (int file, char *devname)
 {
 	int flag, i;
@@ -357,7 +357,7 @@
 
 	return -1;
 }
-
+#endif	//CFG_HEAD_CODE
 /* Called before relocation - use serial functions */
 int console_init_f (void)
 {
@@ -392,6 +392,7 @@
 }
 #endif /* CFG_CONSOLE_IS_IN_ENV || CONFIG_SPLASH_SCREEN */
 
+#ifndef CFG_HEAD_CODE
 #ifdef CFG_CONSOLE_IS_IN_ENV
 /* Called after the relocation - use desired console functions */
 int console_init_r (void)
@@ -570,3 +571,4 @@
 }
 
 #endif /* CFG_CONSOLE_IS_IN_ENV */
+#endif	//CFG_HEAD_CODE
--- a/common/devices.c
+++ b/common/devices.c
@@ -39,6 +39,7 @@
 list_t devlist = 0;
 device_t *stdio_devices[] = { NULL, NULL, NULL };
 char *stdio_names[MAX_FILES] = { "stdin", "stdout", "stderr" };
+#ifndef CFG_HEAD_CODE
 
 #if defined(CONFIG_SPLASH_SCREEN) && !defined(CFG_DEVICE_NULLDEV)
 #define	CFG_DEVICE_NULLDEV	1
@@ -214,3 +215,5 @@
 
 	return 0;
 }
+#endif //CFG_HEAD_CODE
+
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -219,7 +219,9 @@
 	 * We must allocate a buffer for the environment
 	 */
 	env_ptr = (env_t *)malloc (CFG_ENV_SIZE);
-	DEBUGF ("%s[%d] malloced ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
+	if(!env_ptr)
+		DEBUGF ("malloc env_ptr error!!\n");
+	DEBUGF ("%s[%d] malloced ENV at %p\n", __FUNCTION__, __LINE__, env_ptr);
 #endif
 
 	/*
@@ -227,6 +229,10 @@
 	 */
 	env_get_char = env_get_char_memory;
 
+	//leejack
+	DEBUGF ("%s[%d] gd->env_valid=%d\n", __FUNCTION__, __LINE__, gd->env_valid);
+	DEBUGF ("%s[%d] CFG_ENV_SIZE=%d\n", __FUNCTION__, __LINE__, CFG_ENV_SIZE);
+
 	if (gd->env_valid == 0) {
 #if defined(CONFIG_GTH)	|| defined(CFG_ENV_IS_NOWHERE)	/* Environment not changable */
 		puts ("Using default environment\n\n");
@@ -242,18 +248,17 @@
 		}
 
 		memset (env_ptr, 0, sizeof(env_t));
-		memcpy (env_ptr->data,
-			default_environment,
-			sizeof(default_environment));
+		memcpy (env_ptr->data, default_environment, sizeof(default_environment));
+
 #ifdef CFG_REDUNDAND_ENVIRONMENT
 		env_ptr->flags = 0xFF;
 #endif
 		env_crc_update ();
 		gd->env_valid = 1;
-	}
-	else {
+	} else {
 		env_relocate_spec ();
 	}
+
 	gd->env_addr = (ulong)&(env_ptr->data);
 
 #ifdef CONFIG_AMIGAONEG3SE
--- a/common/env_flash.c
+++ b/common/env_flash.c
@@ -66,7 +66,6 @@
 #endif
 
 #else /* ! ENV_IS_EMBEDDED */
-
 env_t *env_ptr = (env_t *)CFG_ENV_ADDR;
 #ifdef CMD_SAVEENV
 static env_t *flash_addr = (env_t *)CFG_ENV_ADDR;
@@ -201,6 +200,7 @@
 	debug (" %08lX ... %08lX ...",
 		(ulong)&(flash_addr_new->data),
 		sizeof(env_ptr->data)+(ulong)&(flash_addr_new->data));
+	
 	if ((rc = flash_write((char *)env_ptr->data,
 			(ulong)&(flash_addr_new->data),
 			sizeof(env_ptr->data))) ||
@@ -256,7 +256,6 @@
 #endif /* CMD_SAVEENV */
 
 #else /* ! CFG_ENV_ADDR_REDUND */
-
 int  env_init(void)
 {
 #ifdef CONFIG_OMAP2420H4
@@ -280,8 +279,55 @@
 
 #ifdef CMD_SAVEENV
 
+#ifdef UBOOT_ENV_COPY
+int saveenv_copy(void) {
+	uchar *env_buffer = (char *)env_ptr;
+	char *kernel_addr;
+	char *rootfs_addr;
+	char *rootfs_size;
+	ulong start_addr,end_addr,rootfs_end_addr;
+	ulong flash_start;
+
+	kernel_addr = getenv("f_kernel_addr");
+	end_addr = simple_strtoul(kernel_addr,NULL,16) - 1;
+	start_addr = end_addr - CFG_ENV_SIZE - sizeof(UBOOTCONFIG_COPY_HEADER) + 1;
+
+	rootfs_addr = getenv("f_rootfs_addr");
+	rootfs_size = getenv("f_rootfs_size");
+	rootfs_end_addr = simple_strtoul(rootfs_addr,NULL,16) + simple_strtoul(rootfs_size,NULL,16);
+
+	if(rootfs_end_addr >= start_addr)
+	{
+		printf("Can not copy the environment at 0x%08lx as no space left.\nf_kernel_addr = 0x%08lx while rootfs_end_addr = 0x%08lx\n",start_addr,end_addr,rootfs_end_addr);
+		return 1;
+	}
+
+	debug ("Protect off %08lX ... %08lX\n", (ulong)rootfs_end_addr, end_addr);
+	if (flash_sect_protect (0, rootfs_end_addr, end_addr))
+		return 1;
+
+	//delete the old environment copy, if found
+	flash_start = rootfs_end_addr;
+	while(flash_start + sizeof(UBOOTCONFIG_COPY_HEADER) + ENV_SIZE < end_addr)
+	{
+		if(strncmp((char *)flash_start,UBOOTCONFIG_COPY_HEADER,sizeof(UBOOTCONFIG_COPY_HEADER)) == 0)
+		{
+			flash_sect_erase(flash_start,flash_start + sizeof(UBOOTCONFIG_COPY_HEADER),1);
+		}
+		flash_start += 1;
+	}
+	flash_sect_erase(start_addr,end_addr,1);
+	flash_write(UBOOTCONFIG_COPY_HEADER,start_addr,sizeof(UBOOTCONFIG_COPY_HEADER));
+	flash_write(env_buffer,start_addr + sizeof(UBOOTCONFIG_COPY_HEADER), CFG_ENV_SIZE);
+	flash_sect_protect (1, rootfs_end_addr, end_addr);
+	printf("saved copy of the env at 0x%08lx\n",start_addr);
+	return 0;
+}
+#endif	//UBOOT_ENV_COPY
+
 int saveenv(void)
 {
+#define debug printf
 	int	len, rc;
 	ulong	end_addr;
 	ulong	flash_sect_addr;
@@ -331,7 +377,7 @@
 		return 1;
 
 	puts ("Erasing Flash...");
-	if (flash_sect_erase (flash_sect_addr, end_addr))
+	if (flash_sect_erase (flash_sect_addr, end_addr, 1))
 		return 1;
 
 	puts ("Writing to Flash... ");
--- a/common/hush.c
+++ b/common/hush.c
@@ -3167,9 +3167,11 @@
 	int code = 0;
 #endif
 	do {
+		printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 		ctx.type = flag;
 		initialize_context(&ctx);
 		update_ifs_map();
+		printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
 		inp->promptmode=1;
 		rcode = parse_stream(&temp, &ctx, inp, '\n');
@@ -3180,9 +3182,12 @@
 			syntax();
 #ifdef __U_BOOT__
 			flag_repeat = 0;
+printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 #endif
+		printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 		}
 		if (rcode != 1 && ctx.old_flag == 0) {
+			printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 			done_word(&temp, &ctx);
 			done_pipe(&ctx,PIPE_SEQ);
 #ifndef __U_BOOT__
@@ -3202,6 +3207,7 @@
 			if (code == -1)
 			    flag_repeat = 0;
 #endif
+		printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 		} else {
 			if (ctx.old_flag != 0) {
 				free(ctx.stack);
@@ -3215,6 +3221,7 @@
 			temp.quote = 0;
 			inp->p = NULL;
 			free_pipe_list(ctx.list_head,0);
+		printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 		}
 		b_free(&temp);
 	} while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP));   /* loop on syntax errors, return on EOF */
@@ -3235,9 +3242,12 @@
 #ifdef __U_BOOT__
 	char *p = NULL;
 	int rcode;
+	printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 	if ( !s || !*s)
 		return 1;
+	printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 	if (!(p = strchr(s, '\n')) || *++p) {
+		printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 		p = xmalloc(strlen(s) + 2);
 		strcpy(p, s);
 		strcat(p, "\n");
@@ -3247,6 +3257,7 @@
 		return rcode;
 	} else {
 #endif
+	printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
 	setup_string_in_str(&input, s);
 	return parse_stream_outer(&input, flag);
 #ifdef __U_BOOT__
--- a/config.mk
+++ b/config.mk
@@ -77,7 +77,7 @@
 sinclude $(TOPDIR)/$(ARCH)_config.mk	# include architecture dependend rules
 endif
 ifdef	CPU
-sinclude $(TOPDIR)/cpu/$(CPU)/config.mk	# include  CPU	specific rules
+sinclude $(TOPDIR)/cpu/$(CPU)/$(BOARD)/config.mk	# include  CPU	specific rules
 endif
 ifdef	SOC
 sinclude $(TOPDIR)/cpu/$(CPU)/$(SOC)/config.mk	# include  SoC	specific rules
@@ -130,7 +130,8 @@
 ARFLAGS = crv
 RELFLAGS= $(PLATFORM_RELFLAGS)
 DBGFLAGS= -g # -DDEBUG
-OPTFLAGS= -Os #-fomit-frame-pointer
+OPTFLAGS= -Os 
+#-O2 #-fomit-frame-pointer
 ifndef LDSCRIPT
 #LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds.debug
 ifeq ($(CONFIG_NAND_U_BOOT),y)
@@ -139,12 +140,15 @@
 LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds
 endif
 endif
+
+LDSCRIPT_BOOTSTRAP := $(TOPDIR)/board/$(BOARDDIR)/u-boot-bootstrap.lds
+
 OBJCFLAGS += --gap-fill=0xff
 
 gccincdir := $(shell $(CC) -print-file-name=include)
 
 CPPFLAGS := $(DBGFLAGS) $(OPTFLAGS) $(RELFLAGS)		\
-	-D__KERNEL__ -DTEXT_BASE=$(TEXT_BASE)		\
+	-D__KERNEL__ -DUBOOT_RAM_TEXT_BASE=$(UBOOT_RAM_TEXT_BASE)		\
 
 ifneq ($(OBJTREE),$(SRCTREE))
 CPPFLAGS += -I$(OBJTREE)/include2 -I$(OBJTREE)/include
@@ -180,7 +184,10 @@
 
 AFLAGS := $(AFLAGS_DEBUG) -D__ASSEMBLY__ $(CPPFLAGS)
 
-LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)
+LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(UBOOT_RAM_TEXT_BASE) $(PLATFORM_LDFLAGS)
+LDFLAGS_BOOTSTRAP += -Bstatic -T $(LDSCRIPT_BOOTSTRAP) -Ttext $(BOOTSTRAP_TEXT_BASE) $(PLATFORM_LDFLAGS)
+
+#HEAD_LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(HEAD_FLASH_TEXT_BASE) $(PLATFORM_LDFLAGS)
 
 # Location of a usable BFD library, where we define "usable" as
 # "built for ${HOST}, supports ${TARGET}".  Sensible values are
@@ -211,10 +218,17 @@
 
 #########################################################################
 
+AFLAGS := $(AFLAGS) $(IFX_CFLAGS)
+CFLAGS := $(CFLAGS) $(IFX_CFLAGS)
+CPPFLAGS := $(CPPFLAGS) $(IFX_CFLAGS)
+
+#########################################################################
+
 export	CONFIG_SHELL HPATH HOSTCC HOSTCFLAGS CROSS_COMPILE \
 	AS LD CC CPP AR NM STRIP OBJCOPY OBJDUMP \
 	MAKE
-export	TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
+#export	UBOOT_RAM_TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
+export	UBOOT_RAM_TEXT_BASE BOOTSTRAP_TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
 
 #########################################################################
 
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -50,14 +50,14 @@
 	  videomodes.o w83c553f.o \
 	  ks8695eth.o \
 	  pxa_pcmcia.o mpc8xx_pcmcia.o tqm8xx_pcmcia.o	\
-	  rpx_pcmcia.o
+	  rpx_pcmcia.o ifx_sw.o
 
 SRCS	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
 
 all:	$(LIB)
 
-$(LIB): $(obj).depend $(OBJS)
+$(LIB):  $(OBJS)
 	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
--- a/include/asm-mips/mipsregs.h
+++ b/include/asm-mips/mipsregs.h
@@ -48,6 +48,7 @@
 #define CP0_CAUSE $13
 #define CP0_EPC $14
 #define CP0_PRID $15
+#define CP0_EBASE $15,1
 #define CP0_CONFIG $16
 #define CP0_LLADDR $17
 #define CP0_WATCHLO $18
@@ -330,11 +331,32 @@
 #  define KSU_USER		0x00000010
 #  define KSU_SUPERVISOR	0x00000008
 #  define KSU_KERNEL		0x00000000
+#ifdef CONFIG_DANUBE	/* MIPS 24KE */
+/* bits 5 & 6 & 7: reserved */
+/* bits 8~15: IM0~7 */
+/* bits 16: reserved */
+#define ST0_CEE			0x00020000
+/* bits 18: always 0 */
+#define ST0_NMI			0x00080000
+#define ST0_SR			0x00100000
+#define ST0_TS			0x00200000
+#define ST0_BEV			0x00400000
+/* bits 23: reserved */
+#define ST0_MX			0x01000000
+#define ST0_RE			0x02000000
+#define ST0_FR			0x04000000
+#define ST0_RP			0x08000000
+#define ST0_CU0			0x10000000
+#define ST0_CU1			0x20000000
+#define ST0_CU2			0x40000000
+#define ST0_CU3			0x80000000
+#else
 #define ST0_UX			0x00000020
 #define ST0_SX			0x00000040
 #define ST0_KX 			0x00000080
 #define ST0_DE			0x00010000
 #define ST0_CE			0x00020000
+#endif
 
 /*
  * Bitfields in the R[23]000 cp0 status register.
@@ -471,6 +493,14 @@
 #define  CAUSEF_BD		(1   << 31)
 
 /*
+ * Bits in the coprocessor 0 EBase register 
+ */
+#define EBASEB_CPUNUM		0
+#define EBASEF_CPUNUM		(0x3ff << EBASEB_CPUNUM)
+#define EBASEB_EXPBASE		12
+#define EBASEF_EXPBASE		(0x3ffff << EBASEB_EXPBASE)
+
+/*
  * Bits in the coprozessor 0 config register.
  */
 #define CONF_CM_CACHABLE_NO_WA		0
@@ -544,4 +574,10 @@
 #define CEB_KERNEL	2	/* Count events in kernel mode EXL = ERL = 0 */
 #define CEB_EXL		1	/* Count events with EXL = 1, ERL = 0 */
 
+/*
+ * Bits in ErrCtl register
+ */
+#define ECCB_WST	29
+#define ECCF_WST	(0x1 << ECCB_WST)
+
 #endif /* _ASM_MIPSREGS_H */
--- a/include/cmd_confdefs.h
+++ b/include/cmd_confdefs.h
@@ -94,6 +94,7 @@
 #define CFG_CMD_EXT2	0x1000000000000000ULL	/* EXT2 Support			*/
 #define CFG_CMD_SNTP	0x2000000000000000ULL	/* SNTP support			*/
 #define CFG_CMD_DISPLAY	0x4000000000000000ULL	/* Display support		*/
+#define CFG_CMD_DHRYSTONE	0x8000000000000000ULL	/* Dhrystone benchmark support		*/
 
 #define CFG_CMD_ALL	0xFFFFFFFFFFFFFFFFULL	/* ALL commands			*/
 
@@ -141,6 +142,7 @@
 			CFG_CMD_SPI	| \
 			CFG_CMD_UNIVERSE | \
 			CFG_CMD_USB	| \
+			CFG_CMD_DHRYSTONE | \
 			CFG_CMD_VFD	)
 
 /* Default configuration
--- /dev/null
+++ b/include/config.h
@@ -0,0 +1,2 @@
+/* Automatically generated - do not edit */
+#include <configs/danube.h>
--- /dev/null
+++ b/include/config.mk
@@ -0,0 +1,3 @@
+ARCH   = mips
+CPU    = mips
+BOARD  = danube
--- a/include/flash.h
+++ b/include/flash.h
@@ -79,7 +79,7 @@
 extern unsigned long flash_init (void);
 extern void flash_print_info (flash_info_t *);
 extern int flash_erase	(flash_info_t *, int, int);
-extern int flash_sect_erase (ulong addr_first, ulong addr_last);
+extern int flash_sect_erase (ulong addr_first, ulong addr_last, unsigned int bPartialErase);
 extern int flash_sect_protect (int flag, ulong addr_first, ulong addr_last);
 
 /* common/flash.c */
@@ -299,6 +299,10 @@
 #define TOSH_ID_FVT160	0xC2		/* TC58FVT160 ID (16 M, top )		*/
 #define TOSH_ID_FVB160	0x43		/* TC58FVT160 ID (16 M, bottom )	*/
 
+#define MX_ID_29LV320AB 0x22A822A8      /* MXIC  MX29LV320AB ID (32 M, bottom ) joelin       */
+#define MX_ID_29LV160BB 0x22492249      /* MXIC  MX29LV160BB ID (16 M, bottom ) joelin       */
+#define MX_ID_29LV640BB 0x22cb22cb      /* MXIC  MX29LV640BB ID (64 M, bottom ) joelin       */
+
 /*-----------------------------------------------------------------------
  * Internal FLASH identification codes
  *
@@ -422,6 +426,10 @@
 #define FLASH_S29GL064M 0x00F0		/* Spansion S29GL064M-R6		*/
 #define FLASH_S29GL128N 0x00F1		/* Spansion S29GL128N			*/
 
+#define FLASH_29LV320AB 0x00B0          /* MXIC MX29LV320AB( 32M = 4M x 16 ) joelin 10/07/2004*/
+#define FLASH_29LV160BB 0x00B1          /* MXIC MX29LV160BB( 16M = 2M x 16 ) joelin 11/22/2004*/
+#define FLASH_29LV640BB 0x00B2          /* MXIC MX29LV640BB( 64M = 8M x 16 ) liupeng*/
+
 #define FLASH_UNKNOWN	0xFFFF		/* unknown flash type			*/
 
 
--- a/include/image.h
+++ b/include/image.h
@@ -132,6 +132,7 @@
 #define IH_COMP_NONE		0	/*  No	 Compression Used	*/
 #define IH_COMP_GZIP		1	/* gzip	 Compression Used	*/
 #define IH_COMP_BZIP2		2	/* bzip2 Compression Used	*/
+#define IH_COMP_LZMA		3	/* lzma Compression Used	*/
 
 #define IH_MAGIC	0x27051956	/* Image Magic Number		*/
 #define IH_NMLEN		32	/* Image Name Length		*/
--- /dev/null
+++ b/include/syscall.h
@@ -0,0 +1,42 @@
+#ifndef __MON_SYS_CALL_H__
+#define __MON_SYS_CALL_H__
+
+#ifndef __ASSEMBLY__
+
+#include <common.h>
+
+/* These are declarations of system calls available in C code */
+int  mon_getc(void);
+int  mon_tstc(void);
+void mon_putc(const char);
+void mon_puts(const char*);
+void mon_printf(const char* fmt, ...);
+void mon_install_hdlr(int, interrupt_handler_t*, void*);
+void mon_free_hdlr(int);
+void *mon_malloc(size_t);
+void mon_free(void*);
+void mon_udelay(unsigned long);
+unsigned long mon_get_timer(unsigned long);
+
+#endif    /* ifndef __ASSEMBLY__ */
+
+#define NR_SYSCALLS            11        /* number of syscalls */
+
+
+/*
+ * Make sure these functions are in the same order as they
+ * appear in the "examples/syscall.S" file !!!
+ */
+#define SYSCALL_GETC           0
+#define SYSCALL_TSTC           1
+#define SYSCALL_PUTC           2
+#define SYSCALL_PUTS           3
+#define SYSCALL_PRINTF         4
+#define SYSCALL_INSTALL_HDLR   5
+#define SYSCALL_FREE_HDLR      6
+#define SYSCALL_MALLOC         7
+#define SYSCALL_FREE           8
+#define SYSCALL_UDELAY         9
+#define SYSCALL_GET_TIMER     10
+
+#endif
--- /dev/null
+++ b/include/version_autogenerated.h
@@ -0,0 +1 @@
+#define U_BOOT_VERSION "U-Boot 1.1.5-IFX-LXDB-g71af1545"
--- /dev/null
+++ b/ld_uboot.conf
@@ -0,0 +1,8 @@
+TAG_DWNLD() 
+{ 
+   0xA0B00000 "u-boot.bin" /* Download u-boot image */ 
+};
+TAG_START()
+{
+   0xA0B00000
+}; /* Start u-boot image */
--- a/lib_generic/Makefile
+++ b/lib_generic/Makefile
@@ -28,7 +28,7 @@
 COBJS	= bzlib.o bzlib_crctable.o bzlib_decompress.o \
 	  bzlib_randtable.o bzlib_huffman.o \
 	  crc32.o ctype.o display_options.o ldiv.o \
-	  string.o vsprintf.o zlib.o
+	  string.o vsprintf.o zlib.o LzmaDecode.o LzmaWrapper.o
 
 SRCS 	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
--- a/lib_mips/board.c
+++ b/lib_mips/board.c
@@ -29,6 +29,25 @@
 #include <net.h>
 #include <environment.h>
 
+#ifdef CFG_HEAD_CODE
+#undef CONFIG_MICROBZIP2
+
+#ifdef CONFIG_BZIP2
+#include <bzlib.h>
+#endif
+
+#ifdef CONFIG_MICROBZIP2
+#include <micro_bzlib.h>
+#endif
+
+#ifdef CONFIG_LZMA
+#include <LzmaWrapper.h>
+#endif
+
+#include <image.h>
+#include "head.h"
+#endif //CFG_HEAD_CODE
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #if ( ((CFG_ENV_ADDR+CFG_ENV_SIZE) < CFG_MONITOR_BASE) || \
@@ -39,8 +58,6 @@
 #define	TOTAL_MALLOC_LEN	CFG_MALLOC_LEN
 #endif
 
-#undef DEBUG
-
 extern int timer_init(void);
 
 extern int incaip_set_cpuclk(void);
@@ -79,6 +96,25 @@
 		mem_malloc_end - mem_malloc_start);
 }
 
+#ifdef CFG_HEAD_CODE
+void *malloc(unsigned int size) {
+	if(size < (mem_malloc_end - mem_malloc_start)) {
+		mem_malloc_start += size;
+		//printf("malloc : size required = 0x%08lx and pointer = 0x%08lx\n",size,mem_malloc_start - size);
+		return (void *)(mem_malloc_start - size);
+	}
+	return NULL;
+}
+
+void *realloc(void *src,unsigned int size) {
+	return NULL;
+}
+
+void free(void *src) {
+	return;
+}
+#endif //CFG_HEAD_CODE 
+
 void *sbrk (ptrdiff_t increment)
 {
 	ulong old = mem_malloc_brk;
@@ -99,7 +135,11 @@
 #else
 	int board_type = 0;	/* use dummy arg */
 #endif
+#ifdef CONFIG_USE_DDR_RAM
+	puts ("DDR-DRAM:  ");
+#else
 	puts ("DRAM:  ");
+#endif
 
 	if ((gd->ram_size = initdram (board_type)) > 0) {
 		print_size (gd->ram_size, "\n");
@@ -116,26 +156,29 @@
 	return (0);
 }
 
+#ifndef CFG_HEAD_CODE
 static void display_flash_config(ulong size)
 {
 	puts ("Flash: ");
 	print_size (size, "\n");
 }
-
+#endif
 
 static int init_baudrate (void)
 {
+#ifndef CFG_HEAD_CODE
 	char tmp[64];	/* long enough for environment variables */
 	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
 
 	gd->baudrate = (i > 0)
 			? (int) simple_strtoul (tmp, NULL, 10)
 			: CONFIG_BAUDRATE;
-
+#else //CFG_HEAD_CODE
+	gd->baudrate = CONFIG_BAUDRATE; 
+#endif //CFG_HEAD_CODE
 	return (0);
 }
 
-
 /*
  * Breath some life into the board...
  *
@@ -160,7 +203,9 @@
 
 init_fnc_t *init_sequence[] = {
 	timer_init,
+#ifndef CFG_HEAD_CODE
 	env_init,		/* initialize environment */
+#endif //CFG_HEAD_CODE
 #ifdef CONFIG_INCA_IP
 	incaip_set_cpuclk,	/* set cpu clock according to environment variable */
 #endif
@@ -179,7 +224,11 @@
 	gd_t gd_data, *id;
 	bd_t *bd;
 	init_fnc_t **init_fnc_ptr;
+#ifdef CFG_HEAD_CODE
+	ulong addr, addr_sp, len = (ulong)&uboot_end - CFG_HEAD_BASE;
+#else //CFG_HEAD_CODE
 	ulong addr, addr_sp, len = (ulong)&uboot_end - CFG_MONITOR_BASE;
+#endif //CFG_HEAD_CODE
 	ulong *s;
 #ifdef CONFIG_PURPLE
 	void copy_code (ulong);
@@ -278,7 +327,8 @@
 #ifdef CONFIG_PURPLE
 	copy_code(addr);
 #endif
-
+	
+	puts("\n relocate_code start");
 	relocate_code (addr_sp, id, addr);
 
 	/* NOTREACHED - relocate_code() does not return */
@@ -292,7 +342,93 @@
  *
  ************************************************************************
  */
+#ifdef CFG_HEAD_CODE
+
+extern void print_image_hdr (image_header_t *hdr);
+extern void jump_unconditional (ulong addr);
+
+void board_init_r (gd_t *id, ulong dest_addr) {
+	int i;
+	ulong	addr;
+	ulong	data, len, checksum;
+	ulong  *len_ptr;
+	image_header_t header;
+	image_header_t *hdr = &header;
+	unsigned int destLen;
 
+	puts("\n relocate code finish.\n");
+
+	/* initialize malloc() area */
+	mem_malloc_init();
+
+	addr = CFG_HEAD_BASE + CFG_UBOOT_OFFSET;
+	memmove (&header, (char *)addr, sizeof(image_header_t));
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+		printf ("Bad Magic Number at address 0x%08lx\n",addr);
+		return;
+	}
+
+	data = (ulong)&header;
+	len  = sizeof(image_header_t);
+
+	checksum = ntohl(hdr->ih_hcrc);
+	hdr->ih_hcrc = 0;
+	if (crc32 (0, (char *)data, len) != checksum) {
+		printf ("Bad Header Checksum\n");
+		return;
+	}
+
+	print_image_hdr (hdr);
+
+	data = addr + sizeof(image_header_t);
+	len  = ntohl(hdr->ih_size);
+	len_ptr = (ulong *)data;
+
+	debug ("Disabling all the interrupts\n");
+	disable_interrupts();
+
+	debug ("   Uncompressing UBoot Image ... \n" );
+	/*
+	 * If we've got less than 4 MB of malloc() space,
+	 * use slower decompression algorithm which requires
+	 * at most 2300 KB of memory.
+	 */
+	destLen = 0x0;
+
+#ifdef CONFIG_BZIP2
+	i = BZ2_bzBuffToBuffDecompress ((char*)ntohl(hdr->ih_load),
+					0x400000, (char *)data, len,
+					CFG_MALLOC_LEN < (4096 * 1024), 0);
+	if (i != BZ_OK) {
+			printf ("BUNZIP2 ERROR %d - must RESET board to recover\n", i);
+			return;
+	}
+#elif CONFIG_MICROBZIP2
+	i = micro_bzBuffToBuffDecompress ((char*)ntohl(hdr->ih_load),
+					&destLen, (char *)data, len,
+					CFG_MALLOC_LEN < (4096 * 1024), 0);
+	if (i != RETVAL_OK) {
+		printf ("MICRO_BUNZIP2 ERROR %d - must RESET board to recover\n", i);
+		return;
+	}
+#elif CONFIG_LZMA
+	i = lzma_inflate ((char *)data, len, (char*)ntohl(hdr->ih_load), &destLen);
+	if (i != LZMA_RESULT_OK) {
+		printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+		return;
+	}
+#else
+	printf ("NONE Compressing u-boot body!!\n");
+	memmove ((void *)ntohl(hdr->ih_load), (uchar *)data, len);
+	destLen = len;
+#endif
+	debug ("   Uncompression completed successfully with destLen %d.\n ",destLen );
+	debug ("Head: Jumping to u-boot in the ram at 0x%08lx\n", CFG_MONITOR_BASE);
+
+	jump_unconditional(CFG_MONITOR_BASE);
+}
+#else //CFG_HEAD_CODE
 void board_init_r (gd_t *id, ulong dest_addr)
 {
 	cmd_tbl_t *cmdtp;
@@ -305,6 +441,8 @@
 	bd_t *bd;
 	int i;
 
+	puts("\n relocate code finish.\n");
+
 	gd = id;
 	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
 
@@ -321,10 +459,10 @@
 		ulong addr;
 
 		addr = (ulong) (cmdtp->cmd) + gd->reloc_off;
-#if 0
-		printf ("Command \"%s\": 0x%08lx => 0x%08lx\n",
+
+		debug ("Command \"%s\": 0x%08lx => 0x%08lx\n",
 				cmdtp->name, (ulong) (cmdtp->cmd), addr);
-#endif
+
 		cmdtp->cmd =
 			(int (*)(struct cmd_tbl_s *, int, int, char *[]))addr;
 
@@ -424,6 +562,7 @@
 
 	/* NOTREACHED - no way out of command loop except booting */
 }
+#endif //CFG_HEAD_CODE
 
 void hang (void)
 {
--- /dev/null
+++ b/lib_mips/head.h
@@ -0,0 +1,3 @@
+
+//#define CFG_HEAD_LEN		0x00006000
+#define CFG_UBOOT_OFFSET	CFG_HEAD_LEN
--- a/lib_mips/time.c
+++ b/lib_mips/time.c
@@ -80,6 +80,17 @@
 		/*NOP*/;
 }
 
+void mdelay (unsigned long msec)
+{
+       int i,j;
+       for(i=0;i<msec;i++)
+       {
+          udelay(1000);
+
+       }
+
+}
+
 /*
  * This function is derived from PowerPC code (read timebase as long long).
  * On MIPS it just returns the timer value.
--- a/net/eth.c
+++ b/net/eth.c
@@ -25,6 +25,9 @@
 #include <command.h>
 #include <net.h>
 #include <miiphy.h>
+#if defined(CONFIG_IFX_MIPS)
+#       include "ifx_eth.c"
+#endif
 
 #if (CONFIG_COMMANDS & CFG_CMD_NET) && defined(CONFIG_NET_MULTI)
 
@@ -54,6 +57,9 @@
 extern int skge_initialize(bd_t*);
 extern int tsec_initialize(bd_t*, int, char *);
 extern int npe_initialize(bd_t *);
+#if defined(CONFIG_IFX_MIPS)
+	IFX_ETH_INITIALIZE_EXTERN
+#endif
 
 static struct eth_device *eth_devices, *eth_current;
 
@@ -235,7 +241,9 @@
 #if defined(CONFIG_RTL8169)
 	rtl8169_initialize(bis);
 #endif
-
+#if defined(CONFIG_IFX_MIPS)
+	IFX_ETH_INITIALIZE(bis)
+#endif
 	if (!eth_devices) {
 		puts ("No ethernet found.\n");
 	} else {
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -23,7 +23,7 @@
 
 BIN_FILES	= img2srec$(SFX) mkimage$(SFX) envcrc$(SFX) gen_eth_addr$(SFX) bmp_logo$(SFX)
 
-OBJ_LINKS	= environment.o crc32.o
+OBJ_LINKS	= environment_$(BOARDDIR).o crc32_$(BOARDDIR).o
 OBJ_FILES	= img2srec.o mkimage.o envcrc.o gen_eth_addr.o bmp_logo.o
 
 ifeq ($(ARCH),mips)
@@ -117,7 +117,7 @@
 CPPFLAGS   = -idirafter $(SRCTREE)/include \
 		-idirafter $(OBJTREE)/include2 \
 		-idirafter $(OBJTREE)/include \
-		-DTEXT_BASE=$(TEXT_BASE) -DUSE_HOSTCC
+		-DTEXT_BASE=$(TEXT_BASE) -DUSE_HOSTCC $(IFX_CFLAGS)
 CFLAGS     = $(HOST_CFLAGS) $(CPPFLAGS) -O
 AFLAGS	   = -D__ASSEMBLY__ $(CPPFLAGS)
 CC	   = $(HOSTCC)
@@ -126,14 +126,14 @@
 
 all:	$(obj).depend $(BINS) $(LOGO_H) subdirs
 
-$(obj)envcrc$(SFX):	$(obj)envcrc.o $(obj)crc32.o $(obj)environment.o
+$(obj)envcrc$(SFX):	$(obj)envcrc.o $(obj)crc32_$(BOARDDIR).o $(obj)environment_$(BOARDDIR).o
 		$(CC) $(CFLAGS) -o $@ $^
 
 $(obj)img2srec$(SFX):	$(obj)img2srec.o
 		$(CC) $(CFLAGS) $(HOST_LDFLAGS) -o $@ $^
 		$(STRIP) $@
 
-$(obj)mkimage$(SFX):	$(obj)mkimage.o $(obj)crc32.o
+$(obj)mkimage$(SFX):	$(obj)mkimage.o $(obj)crc32_$(BOARDDIR).o
 		$(CC) $(CFLAGS) $(HOST_LDFLAGS) -o $@ $^
 		$(STRIP) $@
 
@@ -160,7 +160,7 @@
 $(obj)envcrc.o:	$(src)envcrc.c
 		$(CC) -g $(CFLAGS) -c -o $@ $<
 
-$(obj)crc32.o:	$(obj)crc32.c
+$(obj)crc32_$(BOARDDIR).o:	$(obj)crc32_$(BOARDDIR).c
 		$(CC) -g $(CFLAGS) -c -o $@ $<
 
 $(obj)mkimage.o:	$(src)mkimage.c
@@ -192,16 +192,16 @@
 		done
 endif
 
-$(obj)environment.c:
-		@rm -f $(obj)environment.c
-		ln -s $(src)../common/environment.c $(obj)environment.c
+$(obj)environment_$(BOARDDIR).c:
+		@rm -f $(obj)environment_$(BOARDDIR).c
+		ln -s $(src)../common/environment_$(BOARDDIR).c $(obj)environment_$(BOARDDIR).c
 
-$(obj)environment.o:	$(obj)environment.c
+$(obj)environment_$(BOARDDIR).o:	$(obj)environment_$(BOARDDIR).c
 		$(CC) -g $(HOST_ENVIRO_CFLAGS) $(CPPFLAGS) -c -o $@ $<
 
-$(obj)crc32.c:
-		@rm -f $(obj)crc32.c
-		ln -s $(src)../lib_generic/crc32.c $(obj)crc32.c
+$(obj)crc32_$(BOARDDIR).c:
+		@rm -f $(obj)crc32_$(BOARDDIR).c
+		ln -s $(src)../lib_generic/crc32_$(BOARDDIR).c $(obj)crc32_$(BOARDDIR).c
 
 $(LOGO_H):	$(obj)bmp_logo $(LOGO_BMP)
 		$(obj)./bmp_logo $(LOGO_BMP) >$@
--- a/tools/mkimage.c
+++ b/tools/mkimage.c
@@ -28,6 +28,7 @@
 #ifndef __WIN32__
 #include <netinet/in.h>		/* for host / network byte order conversions	*/
 #endif
+#include <sys/types.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <time.h>
@@ -138,6 +139,7 @@
     {	IH_COMP_NONE,	"none",		"uncompressed",		},
     {	IH_COMP_BZIP2,	"bzip2",	"bzip2 compressed",	},
     {	IH_COMP_GZIP,	"gzip",		"gzip compressed",	},
+    {	IH_COMP_LZMA,	"lzma",		"lzma compressed",	},
     {	-1,		"",		"",			},
 };
 
@@ -445,7 +447,7 @@
 	}
 
 	/* We're a bit of paranoid */
-#if defined(_POSIX_SYNCHRONIZED_IO) && !defined(__sun__) && !defined(__FreeBSD__)
+#if defined(_POSIX_SYNCHRONIZED_IO) && !defined(__sun__) && !defined(__FreeBSD__) && !defined(__APPLE__)
 	(void) fdatasync (ifd);
 #else
 	(void) fsync (ifd);
@@ -495,7 +497,7 @@
 	(void) munmap((void *)ptr, sbuf.st_size);
 
 	/* We're a bit of paranoid */
-#if defined(_POSIX_SYNCHRONIZED_IO) && !defined(__sun__) && !defined(__FreeBSD__)
+#if defined(_POSIX_SYNCHRONIZED_IO) && !defined(__sun__) && !defined(__FreeBSD__) && !defined(__APPLE__)
 	(void) fdatasync (ifd);
 #else
 	(void) fsync (ifd);
